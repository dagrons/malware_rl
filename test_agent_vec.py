import argparse
import multiprocessing as mp
import queue
import time
from datetime import datetime
from multiprocessing import Lock, Process
from multiprocessing.connection import Connection

import gym
from stable_baselines3.ppo import PPO

from random_agent import RandomAgent
from rolling_agent import RollingAgent

agent_cls_map = {
    "ppo": PPO,
    "random": RandomAgent,
    "rolling": RollingAgent
}

# entrypoint for subproc
def _worker(env_name, env_kwargs, agent_name, agent_kwargs, test_args, evasions, evasion_history, idx, counter, counter_lock):        
    # load env     
    env = gym.make(env_name, **env_kwargs)    
    env.seed(idx)    
    agent_cls = agent_cls_map[agent_name]
    if agent_cls == RandomAgent or agent_cls == RollingAgent:
        agent = agent_cls(env)
    else:
        agent = agent_cls.load(test_args["model_path"], env=env, **agent_kwargs)        
    while True:                         
        with counter_lock:
            counter.value -= 1
            if counter.value <= 0:
                return         
        ob = env.reset()
        done = False
        while True:
            action, _ = agent.predict(ob)                        
            ob, reward, done, ep_history = env.step(action)                                
            evasion_history[env.sha256] = ep_history
            if done and reward >= 10:
                evasions.value += 1                                
                break                        
            elif done:
                break            
                

def test(agent_name, agent_kwargs, env_name, env_kwargs, test_kwargs):            
    ctx = mp.get_context("spawn") # spawn an process 
    evasions = ctx.Value('i', 0)        
    manager = ctx.Manager()        
    lock = ctx.Lock()
    counter = ctx.Value('i', test_kwargs["episode_count"]) 
    evasion_history = manager.dict()         
    procs = [ctx.Process(target = _worker, args=(env_name, env_kwargs, agent_name, agent_kwargs, test_kwargs, evasions, evasion_history, i, counter, lock)) for i in range(test_kwargs["num_proc"])]     
    start_time = datetime.now()
    for p in procs: p.start()        
    while True:
        with lock:
            print("finished {} episodes, elasped time: {}".format(test_kwargs["episode_count"] - counter.value, datetime.now() - start_time))                         
            if counter.value <= 0:
                break
        time.sleep(3)
    for p in procs: p.join()                      
    return evasions.value
        
        
# entry point for main process
def main(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--agent", type=str)
    parser.add_argument('--env', type=str)
    parser.add_argument('--ep', type=int)
    parser.add_argument('-j', type=int)
    parser.add_argument('--path', type=str)
    args = parser.parse_args()    
    test_kwargs = {
        "episode_count": args.ep,
        "num_proc": args.j,   
        "model_path": args.path,        
        "outdir": "data/logs/test_agent"
    }
    evasions = test(args.agent, {}, args.env, {}, test_kwargs)    
    evasion_rate = (evasions / args.ep) * 100    
    print(f"{evasion_rate}% samples evaded model.")        
    
    
if __name__ == "__main__":
    main()
    
    
    