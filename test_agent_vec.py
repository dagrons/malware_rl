import argparse
import multiprocessing as mp
import queue
import time
from datetime import datetime
from multiprocessing import Lock, Process
from multiprocessing.connection import Connection

import gym
import numpy as np
from gym import wrappers
from stable_baselines3.ppo import PPO

from random_agent import RandomAgent
from rolling_agent import RollingAgent

agent_cls_map = {
    "ppo": PPO,
    "random": RandomAgent,
    "rolling": RollingAgent
}

# entrypoint for subproc
def _worker(env_name, env_kwargs, agent_name, agent_kwargs, test_args, evasions, evasion_history, ep_lens, idx, counter, counter_lock):        
    # load env     
    env = gym.make(env_name, **env_kwargs)        
    env.seed(idx)    
    env = wrappers.Monitor(env, directory=test_args['outdir'], force=True)
    agent_cls = agent_cls_map[agent_name]
    if agent_cls == RandomAgent or agent_cls == RollingAgent:
        agent = agent_cls(env)
    else:
        agent = agent_cls.load(test_args["model_path"], env=env, **agent_kwargs)        
    while True:                         
        with counter_lock:
            counter.value -= 1
            if counter.value <= 0:
                ep_lens.append(np.mean(env.get_episode_lengths()))        
                return         
        ob = env.reset()
        done = False
        while True:
            action, _ = agent.predict(ob)                        
            ob, reward, done, ep_history = env.step(action)                                
            evasion_history[env.sha256] = ep_history
            if done and reward >= 10:
                evasions.value += 1                                
                break                        
            elif done:
                break           
                

def test(agent_name, agent_kwargs, env_name, env_kwargs, test_kwargs):            
    ctx = mp.get_context("spawn") # spawn an process 
    evasions = ctx.Value('i', 0)       
    manager = ctx.Manager()            
    lock = ctx.Lock()
    counter = ctx.Value('i', test_kwargs["episode_count"]) 
    evasion_history = manager.dict()  
    ep_lens = manager.list()       
    procs = [ctx.Process(target = _worker, args=(env_name, env_kwargs, agent_name, agent_kwargs, test_kwargs, evasions, evasion_history, ep_lens, i, counter, lock)) for i in range(test_kwargs["num_proc"])]     
    start_time = datetime.now()    
    for p in procs: p.start()        
    while True:
        with lock:
            print("finished {} episodes, elasped time: {}".format(test_kwargs["episode_count"] - counter.value, datetime.now() - start_time))                         
            if counter.value <= 0:
                break
        time.sleep(3)
    for p in procs: p.join()  
    mean_ep_len = sum(ep_lens) / len(ep_lens)
    return evasions.value, mean_ep_len
        
        
# entry point for main process
def main(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--agent", type=str)
    parser.add_argument('--env', type=str)
    parser.add_argument('--ep', type=int)
    parser.add_argument('-j', type=int)
    parser.add_argument('--path', type=str)
    args = parser.parse_args()    
    test_kwargs = {
        "episode_count": args.ep,
        "num_proc": args.j,   
        "model_path": args.path,        
        "outdir": "data/logs/test_agent"
    }
    evasions, mean_ep_len = test(args.agent, {}, args.env, {}, test_kwargs)    
    evasion_rate = (evasions / args.ep) * 100    
    print(f"{evasion_rate}% samples evaded model, average ep len: {mean_ep_len}")        
    
    
if __name__ == "__main__":
    main()
    
    
    